import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
// IMPORTANT: Adjust this import path to where your autogenerated Opportunity model is located.
// For example: 'package:your_project_name/models/opportunity.dart'
import '../models/opportunity.dart'; // <--- VERIFY AND ADJUST THIS IMPORT PATH

class PostOpportunityPage extends StatefulWidget {
  const PostOpportunityPage({super.key});

  @override
  State<PostOpportunityPage> createState() => _PostOpportunityPageState();
}

class _PostOpportunityPageState extends State<PostOpportunityPage> {
  final _formKey = GlobalKey<FormState>();

  // --- Form field controllers and variables ---
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _roleController = TextEditingController();
  final TextEditingController _descriptionController = TextEditingController();
  final TextEditingController _locationController = TextEditingController();
  final TextEditingController _requirementsController =
      TextEditingController(); // Input for comma-separated requirements

  // Boolean for paid/unpaid, based on your Opportunity model's 'isPaid'
  bool _isPaid = true;
  // Dropdown selection for opportunity type
  String? _selectedType; // Corresponds to 'type' in your Opportunity model

  // Date fields, using DateTime internally for pickers, then converting to Timestamp
  DateTime? _startDate;
  DateTime? _endDate;
  DateTime? _applicationOpenDate;
  DateTime? _applicationDeadline;
  DateTime? _responseDeadline;
  // --- End form field controllers and variables ---

  // List of opportunity types for the dropdown
  final List<String> _opportunityTypes = [
    'Internship',
    'Full-time',
    'Part-time',
    'Contract',
    'Temporary',
    'Volunteer',
  ];

  @override
  void dispose() {
    _nameController.dispose();
    _roleController.dispose();
    _descriptionController.dispose();
    _locationController.dispose();
    _requirementsController.dispose();
    super.dispose();
  }

  // Helper function to show date picker
  Future<void> _selectDate(
    BuildContext context, {
    required ValueChanged<DateTime> onSelected,
    DateTime? initialDate,
  }) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: initialDate ?? DateTime.now(),
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: const ColorScheme.light(
              primary: Color(0xFFD64483), // Header background color
              onPrimary: Colors.white, // Header text color
              onSurface: Color(0xFF422F5D), // Body text color
            ),
            textButtonTheme: TextButtonThemeData(
              style: TextButton.styleFrom(
                foregroundColor: const Color(0xFFD64483), // Button text color
              ),
            ),
          ),
          child: child!,
        );
      },
    );
    if (picked != null) {
      onSelected(picked);
    }
  }

  // Function to handle the form submission and post the opportunity
  /*Future<void> _postOpportunity() async {
    if (_formKey.currentState!.validate()) {
      _formKey.currentState!.save();

      final User? currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('You must be logged in to post an opportunity.'),
            ),
          );
        }
        return;
      }

      // We link the opportunity to the Firebase Auth UID of the posting company user.
      // This is the 'uid' field in your Company model.
      final String companyAuthUid = currentUser.uid;

      // Parse requirements from the comma-separated string
      List<String> requirementsList = _requirementsController.text
          .split(',')
          .map((e) => e.trim())
          .where((e) => e.isNotEmpty)
          .toList();

      // --- Create an Opportunity object ---
      // We use your autogenerated Opportunity model here.
      // Note: The 'id' field of Opportunity will be the Firestore document ID,
      // which is automatically generated by Firestore's .add() method.
      // 'postedDate' will be server-generated via FieldValue.serverTimestamp() in toMap().
      final Opportunity newOpportunity = Opportunity(
        id: '', // Will be assigned by Firestore automatically when added
        companyId:
            companyAuthUid, // Link to the posting company's Firebase Auth UID
        name: _nameController.text.trim(),
        role: _roleController.text.trim(),
        isPaid: _isPaid,
        type: _selectedType ?? 'Full-time', // Provide a default if not selected
        description: _descriptionController.text.trim().isNotEmpty
            ? _descriptionController.text.trim()
            : null,
        requirements: requirementsList.isNotEmpty ? requirementsList : null,
        location: _locationController.text.trim().isNotEmpty
            ? _locationController.text.trim()
            : null,
        // Convert Dart DateTime objects to Firestore Timestamp objects
        startDate: _startDate != null ? Timestamp.fromDate(_startDate!) : null,
        endDate: _endDate != null ? Timestamp.fromDate(_endDate!) : null,
        applicationOpenDate: _applicationOpenDate != null
            ? Timestamp.fromDate(_applicationOpenDate!)
            : null,
        applicationDeadline: _applicationDeadline != null
            ? Timestamp.fromDate(_applicationDeadline!)
            : null,
        responseDeadline: _responseDeadline != null
            ? Timestamp.fromDate(_responseDeadline!)
            : null,
        postedDate:
            null, // Let Firestore set this via FieldValue.serverTimestamp() in toMap()
        isActive: true, // New opportunities are active by default
      );

      try {
        // Add the new opportunity to the 'opportunities' collection in Firestore
        await FirebaseFirestore.instance
            .collection('opportunities')
            .add(newOpportunity.toFirestore());

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Opportunity posted successfully!')),
          );
          // Navigate back to the previous page (CompanyHomePage)
          Navigator.pop(context);
        }
      } catch (e) {
        debugPrint('Error posting opportunity: $e'); // Log error for debugging
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Failed to post opportunity: ${e.toString()}'),
            ),
          );
        }
      }
    }
  }*/

  // --- START OF THE _postOpportunity() METHOD TO REPLACE ---

  /*Future<void> _postOpportunity() async {
    if (_formKey.currentState!.validate()) {
      _formKey.currentState!.save();

      final User? currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) {
        // IMPORTANT: Check if the widget is still mounted before using context
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('You must be logged in to post an opportunity.'),
            ),
          );
        }
        return; // Exit if no user is logged in
      }

      // We link the opportunity to the Firebase Auth UID of the posting company user.
      final String companyAuthUid = currentUser.uid;

      // Parse requirements from the comma-separated string
      List<String> requirementsList = _requirementsController.text
          .split(',')
          .map((e) => e.trim())
          .where((e) => e.isNotEmpty)
          .toList();

      final Opportunity newOpportunity = Opportunity(
        id: '', // Will be assigned by Firestore automatically when added
        companyId:
            companyAuthUid, // Link to the posting company's Firebase Auth UID
        name: _nameController.text.trim(),
        role: _roleController.text.trim(),
        isPaid: _isPaid,
        type: _selectedType ?? 'Full-time', // Provide a default if not selected
        description: _descriptionController.text.trim().isNotEmpty
            ? _descriptionController.text.trim()
            : null,
        requirements: requirementsList.isNotEmpty ? requirementsList : null,
        location: _locationController.text.trim().isNotEmpty
            ? _locationController.text.trim()
            : null,
        // Convert Dart DateTime objects to Firestore Timestamp objects
        startDate: _startDate != null ? Timestamp.fromDate(_startDate!) : null,
        endDate: _endDate != null ? Timestamp.fromDate(_endDate!) : null,
        applicationOpenDate: _applicationOpenDate != null
            ? Timestamp.fromDate(_applicationOpenDate!)
            : null,
        applicationDeadline: _applicationDeadline != null
            ? Timestamp.fromDate(_applicationDeadline!)
            : null,
        responseDeadline: _responseDeadline != null
            ? Timestamp.fromDate(_responseDeadline!)
            : null,
        postedDate:
            null, // Let Firestore set this via FieldValue.serverTimestamp() in toFirestore()
        isActive: true, // New opportunities are active by default
      );

      try {
        // Add the new opportunity to the 'opportunities' collection in Firestore
        await FirebaseFirestore.instance
            .collection('opportunities')
            .add(newOpportunity.toFirestore());

        // CRITICAL: Check mounted before using context after any 'await' call
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Opportunity posted successfully!')),
          );
          // Navigate back to the previous page (CompanyHomePage)
          Navigator.pop(context); // This also uses context
        }
      } catch (e) {
        // debugPrint does not use context, so it's safe outside of a mounted check
        debugPrint('Error posting opportunity: $e');

        // CRITICAL: Check mounted before using context after any 'await' call
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Failed to post opportunity: ${e.toString()}'),
            ),
          );
        }
      }
    }
  }*/

  // --- END OF THE _postOpportunity() METHOD ---
  // In lib/companyScreens/PostOpportunityPage.dart

  Future<void> _postOpportunity() async {
    if (_formKey.currentState!.validate()) {
      _formKey.currentState!.save();

      final User? currentUser = FirebaseAuth.instance.currentUser;
      // IMPORTANT: Now we need the email, not just existence or UID
      if (currentUser == null) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('You must be logged in to post an opportunity.'),
            ),
          );
        }
        return;
      }

      // ************** CRITICAL CHANGE HERE **************
      // Use the Firebase Auth user's UID as the companyId for the opportunity
      final String companyAuthUid = currentUser.uid;
      // **************************************************

      List<String> requirementsList = _requirementsController.text
          .split(',')
          .map((e) => e.trim())
          .where((e) => e.isNotEmpty)
          .toList();

      final Opportunity newOpportunity = Opportunity(
        id: '', // Will be assigned by Firestore automatically when added
        companyId: companyAuthUid, // Link to the posting company's Firebase Auth UID
        name: _nameController.text.trim(),
        role: _roleController.text.trim(),
        isPaid: _isPaid,
        type: _selectedType ?? 'Full-time',
        description: _descriptionController.text.trim().isNotEmpty
            ? _descriptionController.text.trim()
            : null,
        requirements: requirementsList.isNotEmpty ? requirementsList : null,
        location: _locationController.text.trim().isNotEmpty
            ? _locationController.text.trim()
            : null,
        startDate: _startDate != null ? Timestamp.fromDate(_startDate!) : null,
        endDate: _endDate != null ? Timestamp.fromDate(_endDate!) : null,
        applicationOpenDate: _applicationOpenDate != null
            ? Timestamp.fromDate(_applicationOpenDate!)
            : null,
        applicationDeadline: _applicationDeadline != null
            ? Timestamp.fromDate(_applicationDeadline!)
            : null,
        responseDeadline: _responseDeadline != null
            ? Timestamp.fromDate(_responseDeadline!)
            : null,
        postedDate: null,
        isActive: true,
      );

      try {
        await FirebaseFirestore.instance
            .collection('opportunities')
            .add(newOpportunity.toFirestore());

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Opportunity posted successfully!')),
          );
          Navigator.pop(context);
        }
      } catch (e) {
        debugPrint('Error posting opportunity: $e');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Failed to post opportunity: ${e.toString()}'),
            ),
          );
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    print('DEBUG: PostOpportunityPage build method called.');
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Post New Opportunity',
          style: TextStyle(color: Color(0xFF422F5D)),
        ),
        backgroundColor: const Color(0xFFF7F4F0),
        iconTheme: const IconThemeData(
          color: Color(0xFF422F5D),
        ), // Back button color
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              _buildTextFormField(
                _nameController,
                'Opportunity Name',
                (value) => value!.isEmpty ? 'Please enter a name' : null,
              ),
              _buildTextFormField(
                _roleController,
                'Role',
                (value) => value!.isEmpty ? 'Please enter the role' : null,
              ),
              _buildTextFormField(
                _descriptionController,
                'Description',
                null,
                maxLines: 3,
              ),
              _buildTextFormField(
                _locationController,
                'Location (e.g., Remote, New York)',
                null,
              ),
              _buildTextFormField(
                _requirementsController,
                'Requirements (comma-separated)',
                null,
                keyboardType: TextInputType.text,
              ),

              DropdownButtonFormField<String>(
                value: _selectedType,
                decoration: _buildInputDecoration('Opportunity Type'),
                hint: const Text('Select Type'),
                onChanged: (String? newValue) {
                  setState(() {
                    _selectedType = newValue;
                  });
                },
                validator: (value) =>
                    value == null ? 'Please select a type' : null,
                items: _opportunityTypes.map<DropdownMenuItem<String>>((
                  String type,
                ) {
                  return DropdownMenuItem<String>(
                    value: type,
                    child: Text(type),
                  );
                }).toList(),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    'Paid Opportunity?',
                    style: TextStyle(fontSize: 16),
                  ),
                  Switch(
                    value: _isPaid,
                    onChanged: (bool value) {
                      setState(() {
                        _isPaid = value;
                      });
                    },
                    activeColor: const Color(0xFFD64483),
                  ),
                ],
              ),
              const SizedBox(height: 16),

              _buildDateSelectionField(
                context,
                label: 'Start Date',
                selectedDate: _startDate,
                onSelected: (date) => setState(() => _startDate = date),
              ),
              _buildDateSelectionField(
                context,
                label: 'End Date',
                selectedDate: _endDate,
                onSelected: (date) => setState(() => _endDate = date),
              ),
              _buildDateSelectionField(
                context,
                label: 'Application Open Date',
                selectedDate: _applicationOpenDate,
                onSelected: (date) =>
                    setState(() => _applicationOpenDate = date),
              ),
              _buildDateSelectionField(
                context,
                label: 'Application Deadline',
                selectedDate: _applicationDeadline,
                onSelected: (date) =>
                    setState(() => _applicationDeadline = date),
                validator: (value) =>
                    value == null ? 'Please set a deadline' : null,
              ),
              _buildDateSelectionField(
                context,
                label: 'Response Deadline',
                selectedDate: _responseDeadline,
                onSelected: (date) => setState(() => _responseDeadline = date),
                validator: (value) =>
                    value == null ? 'Please set a response deadline' : null,
              ),
              const SizedBox(height: 30),
              ElevatedButton(
                onPressed: _postOpportunity,
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFFD64483),
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 15),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(30),
                  ),
                ),
                child: const Text(
                  'Post Opportunity',
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Helper for consistent text form fields
  Widget _buildTextFormField(
    TextEditingController controller,
    String label,
    String? Function(String?)? validator, {
    int maxLines = 1,
    TextInputType keyboardType = TextInputType.text,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: TextFormField(
        controller: controller,
        decoration: _buildInputDecoration(label),
        validator: validator,
        maxLines: maxLines,
        keyboardType: keyboardType,
      ),
    );
  }

  // Helper for consistent InputDecorations
  InputDecoration _buildInputDecoration(String label) {
    return InputDecoration(
      labelText: label,
      labelStyle: const TextStyle(color: Color(0xFF6B4791)),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Color(0xFF6B4791)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Color(0xFFD64483), width: 2),
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Color(0x806B4791)),
      ),
      filled: true,
      fillColor: Colors.white,
    );
  }

  // Helper widget for date selection fields
  Widget _buildDateSelectionField(
    BuildContext context, {
    required String label,
    required DateTime? selectedDate,
    required ValueChanged<DateTime> onSelected,
    String? Function(DateTime?)? validator,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: InkWell(
        onTap: () => _selectDate(
          context,
          onSelected: onSelected,
          initialDate: selectedDate,
        ),
        child: InputDecorator(
          decoration: _buildInputDecoration(label).copyWith(
            errorText: validator != null && validator(selectedDate) != null
                ? validator(selectedDate)
                : null,
          ),
          child: Text(
            selectedDate == null
                ? 'Select Date'
                : selectedDate.toLocal().toString().split(' ')[0],
            style: const TextStyle(fontSize: 16, color: Color(0xFF422F5D)),
          ),
        ),
      ),
    );
  }
}
